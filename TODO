DONE

	Add test for server update packet.

	Add test for server response packet.

	Why does the ref backend 5 get a bad server address at the end of the server update packet?

	Is the packet getting truncated somehow?

	No, it was non-pointer receiver for the interface. Needed for write packets. Doesn't work for read.

	Don't process any packet except server init response until server is initialized.

	Hook up code to process the server update response in the server internal.

	When the server response comes back, the server should compare the upcoming magic in the packet with its value.

	If the value is different, then copy across all magic values from the packet into the magic values for the server and print them.

	Change all logs of magic to use %02x in next.cpp

	Verify the server gets upcoming, current and previous magic values by printing them when upcoming changes.

	If the server doesn't get a response within 10 seconds, timeout and fall back to direct mode.

	Find out where I can put state for the server update.

	Check the request id matches before accepting the server response packet.

	Clear the request id when the response is received.

	Check for timeout by seeing if the request id is still non-zero at the time of 

	Extend server to resend the server update once per-second, until the response is received.

	Extend the server init request packet to only send once per-second.

	Extend the server init request to have a timeout (10 seconds).

	There is a race condition now between server init and upgrading clients.

	We must queue upgrade requests until the server init completes, otherwise the upgrade will occur with incorrect magic and screw up the client.

	If I move the destroy command to a mutex protected bool, then I can just buffer commands until the server upgrade completes or has timed out.

	This will do the buffering we need for upgrades... easy.

	Done. Works fine.

	What is left to do to get client and server communicating with valid magic numbers across direct packets?

	The client gets the current magic from the upgrade request initially.

	The client should be extended to get both the upcoming, current and previous magic values instead...

	We can remove the complicated, per-session magic synchronization each route update, and just send down the upcoming/current/previous magic values in each route update, and the client can copy them along.

	The client and server will always send with current magic, but can receive with upcoming, current or previous.

	At this point the client should be able to theoretically upgrade and exchange direct packets with the server.

TODO

	Client is receiving the upgrade request packet, but it's not decoding correctly yet. What's wrong?

	--------------













Exec meeting:

	Turtle Rock acquisition by Tencent. Positive. Q1 or Q2 opportunity for us again. Assume $15k.

	Looker contract. What's going on?

	Update on EA meeting with Sunaina?


B2S:

	Turtle Rock

	Photon

	Velan

	Albion Online

	Mountain Top

	Follow up with Jon and Drew

	Tech follow up with Pragma

	Supercell

	Rec Room

	Valorant

	GGPO team

	Fortnite guys

	Roblox

	WoW guys. Blizzard.

	What other top games?

	----------------------

















	--------------

	Client also needs to be able to read packets sent with current, upcoming and previous magic (in that order).

	Do we still need complicated acks between the client and server for which magic to send with? I don't think so...

	--------------








	--------------

	The server is in a mode where it will send server init request forever until it gets a response.

	Server init should timeout if no response is received within 30 seconds...

	--------------

	Now the server can init, verify that server updates get through to the reference backend 5.

	--------------

	Extend the server update to have a server update response which includes the current magic.

	--------------

	Verify that the server gets updated magic every minute, as they charge 

	--------------

















	--------------

	Fix up the "GetAddressData" function to work properly with IPv4 and IPv6

	--------------

	Bring across "GetAddressData" function into core.go and port across tests from C++

	--------------


















	--------------

	Now verify that the server can upgrade a client and exchange direct packets.

	--------------

	From this point get as many func tests working with direct packets as possible.

	--------------




















	==================================
	Get the client/server upgrade working and the upgraded direct packets being exchanged between client and server.

	--------------

	Update the func backend 5 so it can handle new SDK5 packet types.

	--------------

	Get various upgraded direct func tests passing.

	--------------






























	========================================================

	--------------

	Work out how to get ping tokens down to the client

	--------------

	Get the client pinging near relays w. ping tokens and getting responses.

	--------------

	Update the reference relay so it can handle the new SDK5 packet types.

	--------------

	Get an actual end-to-end network next route going with SDK5 client/server.

	--------------

	Get the rest of the func tests passing.

	--------------

	=================================================

	--------------

	Move server whois to the backend, it's unreliable when run on the SDK server
	and the iteration time for fixes (new SDK deploy) is just too long.

	--------------

	We need a server flush method to timeout all sessions and flush session updates until acked.

	--------------









	--------------

	Routing private key should be properly secured and not included in source code.

	--------------
