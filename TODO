DONE

	Add a goroutine to the reference backend 5 to generate a new magic every 60 seconds.

	Add a "getMagic" function to safely get the magic w. read lock as needed.

	Log the magic when it changes in the ref backend.

	Extend server init response packet to include current magic value.

	Extend the server init response packet send to check the packet filters before sending.
	
	Verify that the server gets the initial magic value sent down in init response (via log).

	Instead of having any complex logic on the server, client or relays...

	There should be three magics at any time.

	1. Upcoming
	2. Current
	3. Previous

	The relay, client and server will always use #2, current for sending, but will be able to read any of the 3.

	This way clients, servers and relays don't have any waiting time until they can communicate, they don't need to cache
	upcoming/current/previous and run timers. This is all done on the backend.

	On the backend, initially three random magics are selected. Then every 60 seconds, current -> previous, upcoming -> current, and roll a new upcoming.

	Then these three values are simply transmitted down to the server and relays, which just run the simple logic described above, without timers or change overs or caching or any delay waiting for upcoming to be ready.

	This works. Switch to this now.

	Server now gets the three magic values in server init response packet.

	Remove the delay code that waits 30 seconds before using magic on server.

	Remove the magic from the session update response packet. It will come down in the server update response instead.

	Server needs to store upcoming, current and previous magic values from server init.

	Extend server so it is able to read packets sent with current, upcoming and previous magic (in that order).

	Work out how the server will associate the response with its update (prefer not to use sequence number, instead random 32 byte value that is compared, eg. request id?)

	Extend the server update packet to have a 32 byte request id.

	Sketch out the server response packet. 

	It should have a random 32 byte request id. 

	It should return the upcoming, current and previous magic values (8 bytes each).

	Add a test to verify the server update response serializes correctly.

	Extend the server to roll a random request id for each server update packet.

	Shuffle packet ids to fit in the server update, server response.

	Sketch out the handler for server update -> server response in the ref backend5.

	Remove ping system

TODO

	--------------

	Server address in update packet appears to be empty, or not serializing correctly. What's going on?

	--------------

	Clean up ref backend 5 by adding SendResponsePacket function.

	--------------

	Test for server update packet.

	--------------

	Test for server response packet.

	--------------

	Hook up the server response packet in read backend packet, and processing on the server internal.

	--------------

	Extend server to resend the server update 5 times, once per-second, until it gets an response with matching request id.

	This can be modelled on how it is done for the server init request packet...

	If the server doesn't get response, it should fall back to direct mode and stop communicating with the server backend.

	--------------

	When the server response comes back, the server should compare the upcoming magic in the packet with its value.

	If the value is different, then copy across all magic values from the packet into the magic values for the server and print them.

	--------------

	Add the server response packet type to the reference backend 5.

	--------------

	Extend the reference backend 5 so it responds to the server update packet with a server response packet, with the same request id, and including the current magic values.

	--------------

	Change all logs of magic to use %02x in next.cpp

	--------------

	Verify the server gets upcoming, current and previous magic values by printing them when upcoming changes.

	--------------



























	--------------

	Client also needs to be able to read packets sent with current, upcoming and previous magic (in that order).

	Do we still need complicated acks between the client and server for which magic to send with? I don't think so...

	--------------








	--------------

	The server is in a mode where it will send server init request forever until it gets a response.

	Server init should timeout if no response is received within 30 seconds...

	--------------

	Now the server can init, verify that server updates get through to the reference backend 5.

	--------------

	Extend the server update to have a server update response which includes the current magic.

	--------------

	Verify that the server gets updated magic every minute, as they charge 

	--------------

















	--------------

	Fix up the "GetAddressData" function to work properly with IPv4 and IPv6

	--------------

	Bring across "GetAddressData" function into core.go and port across tests from C++

	--------------


















	--------------

	Now verify that the server can upgrade a client and exchange direct packets.

	--------------

	From this point get as many func tests working with direct packets as possible.

	--------------




















	==================================
	Get the client/server upgrade working and the upgraded direct packets being exchanged between client and server.

	--------------

	Update the func backend 5 so it can handle new SDK5 packet types.

	--------------

	Get various upgraded direct func tests passing.

	--------------






























	========================================================

	--------------

	Work out how to get ping tokens down to the client

	--------------

	Get the client pinging near relays w. ping tokens and getting responses.

	--------------

	Update the reference relay so it can handle the new SDK5 packet types.

	--------------

	Get an actual end-to-end network next route going with SDK5 client/server.

	--------------

	Get the rest of the func tests passing.

	--------------

	=================================================

	--------------

	Move server whois to the backend, it's unreliable when run on the SDK server
	and the iteration time for fixes (new SDK deploy) is just too long.

	--------------

	We need a server flush method to timeout all sessions and flush session updates until acked.

	--------------









	--------------

	Routing private key should be properly secured and not included in source code.

	--------------
