DONE

	Add a goroutine to the reference backend 5 to generate a new magic every 60 seconds.

	Add a "getMagic" function to safely get the magic w. read lock as needed.

	Log the magic when it changes in the ref backend.

	Extend server init response packet to include current magic value.

	Extend the server init response packet send to check the packet filters before sending.
	
TODO

	--------------

	Verify that the server gets the initial magic value sent down in init response (via log).

	--------------

	I think we need a concept of read and write magic across the board (relay, client, server).

	This means that a new magic value goes out, but it's not used for writing, until all components in the system
	are sure to have it, eg. relays, clients and servers.

	When the number flips over, we fix race conditions by having all components knowing the upcoming write magic value, but not writing with it until 30 seconds.

	eg. a relay might switch over 1 sec earlier than a server -- but the server already knows how to read packets encoded with the upcoming magic for 30 seconds now...

	think this through. it has to be perfectly robust.

	--------------








	--------------

	The server is in a mode where it will send server init request forever until it gets a response.

	Server init should timeout if no response is received within 30 seconds...

	--------------

	Now the server can init, verify that server updates get through to the reference backend 5.

	--------------

	Extend the server update to have a server update response which includes the current magic.

	--------------

	Verify that the server gets updated magic every minute, as they charge 

	--------------

















	--------------

	Think through exactly how the server should wait 30 seconds before it uses the magic value... ?

	Seems like it should wait until it gets 3 server update responses until it considers itself fully inited?

	--------------

	But the server can't upgrade players until it knows the magic...

	This means we have a new state, where the server is unable to upgrade players, for the first 30 seconds.

	This kinda sucks.

	--------------

	Maybe the server should remember each player to be upgraded, if the upgrade is performed while the init is in progress,
	and then actually start the upgrade process, post-30 seconds and init... ?

	--------------













	--------------

	Fix up the "GetAddressData" function to work properly with IPv4 and IPv6

	--------------

	Bring across "GetAddressData" function into core.go and port across tests from C++

	--------------


















	--------------

	Now verify that the server can upgrade a client and exchange direct packets.

	--------------

	From this point get as many func tests working with direct packets as possible.

	--------------




















	==================================
	Get the client/server upgrade working and the upgraded direct packets being exchanged between client and server.

	--------------

	Update the func backend 5 so it can handle new SDK5 packet types.

	--------------

	Get various upgraded direct func tests passing.

	--------------






























	========================================================

	--------------

	Work out how to get ping tokens down to the client

	--------------

	Get the client pinging near relays w. ping tokens and getting responses.

	--------------

	Update the reference relay so it can handle the new SDK5 packet types.

	--------------

	Get an actual end-to-end network next route going with SDK5 client/server.

	--------------

	Get the rest of the func tests passing.

	--------------

	=================================================

	--------------

	Move server whois to the backend, it's unreliable when run on the SDK server
	and the iteration time for fixes (new SDK deploy) is just too long.

	--------------

	We need a server flush method to timeout all sessions and flush session updates until acked.

	--------------









	--------------

	Routing private key should be properly secured and not included in source code.

	--------------
